"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const util_1 = require("util");
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const dedent_1 = tslib_1.__importDefault(require("dedent"));
const ansi_colors_1 = require("ansi-colors");
const obsidian_utils_1 = require("obsidian-utils");
const build_1 = require("../build");
const config_1 = require("../config");
const localManifestPath = path_1.default.join(process.cwd(), "manifest.json");
const read = util_1.promisify(fs_1.default.readFile);
const mkdir = (path) => {
    if (fs_1.default.existsSync(path))
        return;
    return fs_1.default.mkdirSync(path, { recursive: true });
};
class Dev extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Dev);
        let { ["esbuild-config"]: esbuildConfigPath, ["vault-path"]: vaultPath, ["no-prompts"]: noPrompts, } = flags;
        const [configError, esbuildConfig] = await obsidian_utils_1.to(config_1.getConfig(args.entryPoint, esbuildConfigPath));
        if (configError) {
            this.error(configError);
        }
        if (!fs_1.default.existsSync(localManifestPath)) {
            this.error("Your project should have a manifest.json file in its root but none was found");
        }
        const manifest = JSON.parse(await read(localManifestPath, "utf-8"));
        const [vaultError, vaults] = await obsidian_utils_1.to(obsidian_utils_1.findVault(vaultPath));
        if (vaultError || !vaults || vaults.length === 0) {
            if (noPrompts) {
                this.error(`No vault could be located\n${vaultError}`.trim());
            }
            if (vaults && vaults.length) {
                let { selectedVaultPath } = await prompts_1.default({
                    name: "selectedVaultPath",
                    type: "select",
                    message: "Select a vault",
                    choices: [
                        {
                            title: "none of these",
                            description: "Manually enter your vault path",
                            value: "",
                        },
                        ...vaults.map((v) => ({
                            title: v.name,
                            value: v.path,
                        })),
                    ],
                });
                if (selectedVaultPath) {
                    vaultPath = selectedVaultPath;
                }
                else {
                    let { selectedVaultPath } = await prompts_1.default({
                        name: "selectedVaultPath",
                        message: "Enter the path to your vault",
                        type: "text",
                        validate: (v) => obsidian_utils_1.isVault(v) || `${v} is not a valid vault, try again`,
                    });
                    if (!selectedVaultPath)
                        this.error(`No vault selected`);
                    vaultPath = selectedVaultPath;
                }
            }
            else {
                let { selectedVaultPath } = await prompts_1.default({
                    name: "selectedVaultPath",
                    message: "Enter the path to your vault",
                    type: "text",
                    validate: (v) => obsidian_utils_1.isVault(v) || `${v} is not a valid vault, try again`,
                });
                if (!selectedVaultPath)
                    this.error(`No vault selected`);
                vaultPath = selectedVaultPath;
            }
        }
        else if (vaults.length === 1) {
            vaultPath = vaults[0].path;
        }
        else {
            const openedVaults = vaults.filter((vault) => vault.open);
            if (noPrompts && openedVaults.length === 1) {
                this.log(dedent_1.default `
          Using vault ${openedVaults[0].name} given it's the last opened
          If that's not the intended vault, enable prompts or pass vault path instead
        `);
                vaultPath = openedVaults[0].path;
            }
            else if (noPrompts) {
                this.error(`Unsure which vault to select: ${vaults
                    .map((vault) => vault.name)
                    .join(",")}`);
            }
            else {
                const { selectedVaultPath } = await prompts_1.default({
                    type: "select",
                    name: "selectedVaultPath",
                    message: "Select the vault to develop in",
                    choices: vaults.map((vault) => ({
                        title: vault.name,
                        value: vault.path,
                        description: vault.open ? "recently opened" : undefined,
                    })),
                });
                if (!selectedVaultPath)
                    this.error(`No vault was selected`);
                vaultPath = selectedVaultPath;
            }
        }
        const pluginPath = path_1.default.join(vaultPath, ".obsidian", "plugins", manifest.id);
        const pluginManifestPath = path_1.default.join(pluginPath, "manifest.json");
        const copyConfig = () => {
            mkdir(pluginPath);
            fs_1.default.copyFileSync(localManifestPath, pluginManifestPath);
        };
        copyConfig();
        if (!(await obsidian_utils_1.isPluginInstalled("hot-reload", vaultPath)) && !noPrompts) {
            const { installHotReload } = await prompts_1.default({
                name: "installHotReload",
                type: "confirm",
                message: `Would you like to install pjeby's hot-reload plugin to have your plugin reload on change? ${ansi_colors_1.dim("(recommended)")}`,
            });
            if (installHotReload) {
                this.log("Installing hot-reload from github...");
                await obsidian_utils_1.installPluginFromGithub("pjeby/hot-reload", "latest", vaultPath);
                fs_1.default.openSync(path_1.default.join(pluginPath, ".hotreload"), "w");
                this.log(`${ansi_colors_1.green("Success!")} You'll need to ${ansi_colors_1.bold(ansi_colors_1.underline("reload obsidian (CMD+R)"))} and ${ansi_colors_1.bold(ansi_colors_1.underline("enable the plugin"))} for hot-reloading to start!`);
            }
        }
        fs_1.default.watch(localManifestPath, (eventType) => {
            if (eventType === "change") {
                this.log("Manifest file changed, copying it to your vault");
                copyConfig();
            }
        });
        await build_1.build(Object.assign({ outfile: path_1.default.join(pluginPath, "main.js"), watch: true }, esbuildConfig));
    }
}
exports.default = Dev;
Dev.description = dedent_1.default `
    builds in watch mode and copies output to a specified vault for testing

    If ${ansi_colors_1.bold("--vault-path")} is not specified, this command will try to intelligently determine where your vaults are located.
    If it's able to locate your vaults, you'll be given the option to select which vault you'd like to develop against. 
    If, however, ${ansi_colors_1.bold("--no-prompts")} is passed it will assume the last opened vault (if one is found) will be the vault to develop 
    against. If that's not the behavior you desire, ensure to pass the explicit path to the vault you want to develop against 
    with ${ansi_colors_1.bold("--vault-path")}.
  `;
Dev.flags = {
    help: command_1.flags.help({ char: "h" }),
    ["esbuild-config"]: command_1.flags.string({
        char: "e",
        description: "path to a JSON file over esbuild options to enhance/override the current build",
    }),
    ["vault-path"]: command_1.flags.string({
        char: "v",
        description: "path to the obsidian vault you want to develop in",
        default: "",
    }),
    ["no-prompts"]: command_1.flags.boolean({
        char: "n",
        description: "disable prompting for user input",
    }),
};
Dev.args = [{ name: "entryPoint" }];
