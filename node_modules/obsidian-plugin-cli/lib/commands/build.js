"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const build_1 = require("../build");
const config_1 = require("../config");
const obsidian_utils_1 = require("obsidian-utils");
class Build extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Build);
        const { ["esbuild-config"]: esbuildConfigPath, ["output-dir"]: outputDir, } = flags;
        const [configError, esbuildConfig] = await obsidian_utils_1.to(config_1.getConfig(args.entryPoint, esbuildConfigPath));
        if (configError) {
            this.error(configError);
        }
        await build_1.build(Object.assign({ outfile: path_1.default.join(outputDir, "main.js"), minify: true }, esbuildConfig));
        fs_1.default.copyFileSync("./manifest.json", path_1.default.join(outputDir, "manifest.json"));
    }
}
exports.default = Build;
Build.description = "builds plugin for release";
Build.flags = {
    help: command_1.flags.help({ char: "h" }),
    ["esbuild-config"]: command_1.flags.string({
        char: "e",
        description: "path to a config file containing esbuild options to apply to the build",
    }),
    ["output-dir"]: command_1.flags.string({
        char: "o",
        description: "path to write build output to",
        default: "dist",
    }),
};
Build.args = [{ name: "entryPoint" }];
