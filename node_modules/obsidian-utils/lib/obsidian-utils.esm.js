// polyfill/fetch.esm.js
var fetchPolyfill = (...args) => {
  if (typeof window !== "undefined") {
    return window.fetch(...args);
  }
  return import("node-fetch")(...args);
};

// ../../node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// ../../node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// ../../node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// ../../node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// ../../node_modules/date-fns/esm/addMinutes/index.js
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}

// ../../node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// ../../node_modules/date-fns/esm/subMinutes/index.js
function subMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}

// src/utils.ts
import {Readable} from "stream";
import {promisify} from "util";
import fs from "fs";
import path from "path";
var mkdir = promisify(fs.mkdir);
var read = promisify(fs.readFile);
var write = promisify(fs.writeFile);
var fileStats = promisify(fs.stat);
var rmdir = promisify(fs.rmdir);
var readDir = promisify(fs.readdir);
var copyFile = promisify(fs.copyFile);
var readJSON = (filePath) => read(filePath, "utf-8").then((contents) => JSON.parse(contents));
function failIfNot(condition, message) {
  if (!condition)
    throw new Error(message);
}
function failIf(condition, message) {
  if (condition)
    throw new Error(message);
}
var to = (p) => {
  return p.then((v) => [null, v]).catch((e) => [e, null]);
};
var resToReadable = (res) => {
  failIfNot(res.body, "Response has no body");
  if ("pipe" in res.body) {
    return res.body;
  }
  const reader = res.body.getReader();
  const readable = new Readable();
  readable._read = async () => {
    const {done, value} = await reader.read();
    if (value)
      readable.push(done ? null : Buffer.from(value));
  };
  return readable;
};
var toRead = (...pathParts) => to(read(path.join(...pathParts), "utf-8"));
var toWrite = (payload, ...pathParts) => to(write(path.join(...pathParts), payload));
var toReadJSON = (...pathParts) => to(read(path.join(...pathParts), "utf-8").then((content) => JSON.parse(content)));
var fetchJSON = (...args) => fetchPolyfill(...args).then((res) => res.json());
var fetchToDisk = (input, outPath, init) => fetchPolyfill(input, init).then(async (res) => {
  const outputFileStream = fs.createWriteStream(outPath);
  const downloadStream = resToReadable(res);
  downloadStream.pipe(outputFileStream);
  return new Promise((resolve, reject) => {
    outputFileStream.on("error", reject);
    downloadStream.on("error", reject);
    downloadStream.on("end", resolve);
  });
});

// src/log.ts
var logger = (level, ...args) => {
};
var registerLogger = (fn) => {
  logger = (level, ...args) => {
    fn("obsidian-utils", level, ...args);
  };
};
var debug = (...args) => logger("debug", ...args);

// src/plugin/registry.ts
var DEFAULT_REGISTRY_URL = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugins.json";
var PluginRegistry2 = class {
  constructor(registryURL = DEFAULT_REGISTRY_URL) {
    this.registryURL = registryURL;
  }
  async updateRegistry() {
    debug("Fetching the plugin registry...");
    const [pluginRegistryFetchError, pluginRegistry] = await to(fetchPolyfill(this.registryURL).then((response) => response.json()));
    failIf(pluginRegistryFetchError, "Failed to fetch the plugin registry from github");
    PluginRegistry2._registry = pluginRegistry;
    debug("Plugin registry downloaded");
  }
  async getRegistry() {
    const registry = PluginRegistry2._registry;
    if (isBefore(registry.lastUpdated, subMinutes(Date.now(), 5))) {
      await this.updateRegistry();
    }
    return registry;
  }
  async getPlugin(pluginID) {
    const registry = await this.getRegistry();
    return registry.plugins.find((plugin) => plugin.id === pluginID);
  }
};
var PluginRegistry = PluginRegistry2;
PluginRegistry._registry = {
  lastUpdated: new Date(0),
  plugins: []
};

// src/plugin/install.ts
import fs2 from "fs";
import path3 from "path";

// src/plugin/utils.ts
import path2 from "path";
var vaultPathToPluginsPath = (vaultPath) => {
  return path2.join(vaultPath, ".obsidian", "plugins");
};

// src/plugin/install.ts
async function installPluginFromGithub(repo, version, vaultPath) {
  var _a;
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const [pluginReleaseFetchError, pluginReleaseInfo] = await to(fetchPolyfill(version === "latest" ? `https://api.github.com/repos/${repo}/releases/latest` : `https://api.github.com/repos/${repo}/releases/tags/${version}`, {
    method: "GET",
    headers: {Accept: "application/vnd.github.v3+json"}
  }).then((response) => response.json()));
  failIf(pluginReleaseFetchError, `Failed to get release information from GitHub. You should install this plugin manually.`);
  debug(`retrieved release info from ${repo}`);
  debug("Finding manifest from release...");
  const manifestDownloadPath = (_a = pluginReleaseInfo.assets.find((asset) => asset.name === "manifest.json")) == null ? void 0 : _a.browser_download_url;
  failIfNot(manifestDownloadPath, `Didn't find a manifest.json file in release. Check it here: https://github.com/${repo}/releases/tag/${version}`);
  const [manifestDownloadError, manifest] = await to(fetchJSON(manifestDownloadPath));
  failIf(manifestDownloadError, `Failed to download manifest.json.
${manifestDownloadError}`);
  failIfNot(manifest, `manifest.json is empty`);
  const pluginID = manifest.id;
  const pluginPath = path3.join(pluginsPath, pluginID);
  debug("Creating plugin directory if it doesn't exist...");
  if (!fs2.existsSync(pluginPath)) {
    await mkdir(pluginPath, {recursive: true});
    debug("plugin directory successfully created");
  }
  await write(path3.join(pluginPath, "manifest.json"), JSON.stringify(manifest));
  await Promise.all(pluginReleaseInfo.assets.filter((asset) => asset.name !== "manifest.json" && (asset.name.endsWith(".js") || asset.name.endsWith(".json"))).map((asset) => fetchToDisk(asset.browser_download_url, path3.join(pluginPath, asset.name))));
  debug(`${pluginID} successfully installed`);
}
async function installPluginFromRegistry(pluginID, version, vaultPath, registry = new PluginRegistry()) {
  debug(`Attempting to install ${pluginID}`);
  debug("Trying to retrieve", pluginID, "from plugin registry");
  const plugin = await registry.getPlugin(pluginID);
  failIfNot(plugin, `Unable to install ${plugin}, it wasn't found in the registry.`);
  debug(pluginID, "found in plugin registry");
  return installPluginFromGithub(plugin.repo, version, vaultPath);
}
async function installLocalPlugin(pluginPath, vaultPath) {
  debug(`Attempting to install ${path3.basename(pluginPath)} to ${path3.basename(vaultPath)} vault`);
  const [manifestReadError, manifest] = await toReadJSON(pluginPath, "manifest.json");
  failIf(manifestReadError, `Failed to read manifest:
${manifestReadError}`);
  failIfNot(manifest, `Something went wrong, tried to read manifest but it was empty`);
  const {id} = manifest;
  const newPluginPath = path3.join(vaultPathToPluginsPath(vaultPath), id);
  if (fs2.existsSync(newPluginPath)) {
    debug("Plugin found with same name at the install location, removing it");
    await rmdir(newPluginPath, {recursive: true, force: true});
    await mkdir(newPluginPath);
  }
  const [readDirError, files] = await to(readDir(pluginPath));
  failIf(readDirError, `Something went wrong reading files from ${pluginPath}
${readDirError}`);
  failIfNot(files, `Something went wrong reading files from ${pluginPath}, expected to get files but got null instead`);
  for (const file of files) {
    await copyFile(path3.join(pluginPath, file), path3.join(newPluginPath, file));
  }
  debug("Install complete");
}

// src/plugin/local.ts
import path4 from "path";
async function getInfoOnInstalledPlugin(pluginID, vaultPath) {
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const manifestPath = path4.join(pluginsPath, pluginID, "manifest.json");
  const [manifestReadError, manifest] = await toReadJSON(manifestPath);
  failIf(manifestReadError, `Manifest failed to load: ${manifestReadError}`);
  failIfNot(manifest, `Manifest loaded but wasn't defined`);
  const [, data] = await toReadJSON(vaultPath, pluginID, "data.json");
  const results = {
    manifest,
    data: data != null ? data : void 0,
    lastUpdated: (await fileStats(manifestPath)).mtime
  };
  debug(`Successfully fetched plugin from disk`);
  debug(results);
  return results;
}
async function isPluginInstalled(pluginID, vaultPath) {
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const [manifestReadError, manifest] = await toReadJSON(pluginsPath, pluginID, "manifest.json");
  if (manifestReadError) {
    debug(`Got manifest error`, manifestReadError);
  }
  return manifestReadError || !manifest ? false : true;
}

// src/vault.ts
import os from "os";
import path5 from "path";
import fs3 from "fs";
var isVault = (vaultPath) => {
  if (typeof vaultPath === "string" && fs3.existsSync(path5.join(vaultPath, ".obsidian"))) {
    return true;
  }
  return false;
};
var getVaultFromPath = (vaultPath, open) => {
  return {
    name: path5.basename(vaultPath),
    path: vaultPath,
    open
  };
};
var findVault = async (vaultPath) => {
  var _a;
  if (isVault(vaultPath)) {
    return [getVaultFromPath(vaultPath)];
  }
  if (vaultPath && fs3.existsSync(vaultPath)) {
    return [getVaultFromPath(vaultPath)];
  }
  const home = os.homedir();
  let obsidianPath = "";
  switch (os.platform()) {
    case "win32":
      obsidianPath = path5.join(home, "AppData", "Local", "Obsidian");
      break;
    case "darwin":
      obsidianPath = path5.join(home, "Library", "Application Support", "Obsidian");
      break;
    default: {
      const obsidianHomePath = path5.join(home, ".obsidian");
      const obsidianConfigPath = path5.join(home, ".config", "obsidian");
      const XDG = (_a = process.env.XDG) != null ? _a : "";
      const XDGPath = path5.join(XDG, "obsidian");
      obsidianPath = fs3.existsSync(obsidianConfigPath) ? obsidianConfigPath : XDG && fs3.existsSync(XDGPath) ? XDGPath : obsidianHomePath;
    }
  }
  failIf(!fs3.existsSync(obsidianPath), "Can't find obsidian settings directory, won't be able to read vaults");
  const [obsidianReadError, obsidian] = await to(readJSON(path5.join(obsidianPath, "obsidian.json")));
  failIf(obsidianReadError, `Could not read obsidian.json: ${obsidianReadError}
Vaults won't be retrievable`);
  return Object.values(obsidian.vaults).map((vault) => getVaultFromPath(vault.path, vault.open));
};
export {
  PluginRegistry,
  copyFile,
  failIf,
  failIfNot,
  fetchJSON,
  fetchToDisk,
  fileStats,
  findVault,
  getInfoOnInstalledPlugin,
  installLocalPlugin,
  installPluginFromGithub,
  installPluginFromRegistry,
  isPluginInstalled,
  isVault,
  mkdir,
  read,
  readDir,
  readJSON,
  registerLogger,
  rmdir,
  to,
  toRead,
  toReadJSON,
  toWrite,
  vaultPathToPluginsPath,
  write
};
