var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// src/obsidian-utils.ts
__markAsModule(exports);
__export(exports, {
  PluginRegistry: () => PluginRegistry,
  copyFile: () => copyFile,
  failIf: () => failIf,
  failIfNot: () => failIfNot,
  fetchJSON: () => fetchJSON,
  fetchToDisk: () => fetchToDisk,
  fileStats: () => fileStats,
  findVault: () => findVault,
  getInfoOnInstalledPlugin: () => getInfoOnInstalledPlugin,
  installLocalPlugin: () => installLocalPlugin,
  installPluginFromGithub: () => installPluginFromGithub,
  installPluginFromRegistry: () => installPluginFromRegistry,
  isPluginInstalled: () => isPluginInstalled,
  isVault: () => isVault,
  mkdir: () => mkdir,
  read: () => read,
  readDir: () => readDir,
  readJSON: () => readJSON,
  registerLogger: () => registerLogger,
  rmdir: () => rmdir,
  to: () => to,
  toRead: () => toRead,
  toReadJSON: () => toReadJSON,
  toWrite: () => toWrite,
  vaultPathToPluginsPath: () => vaultPathToPluginsPath,
  write: () => write
});

// polyfill/fetch.js
var fetchPolyfill = (...args) => {
  if (typeof window !== "undefined") {
    return window.fetch(...args);
  }
  return require("node-fetch")(...args);
};

// ../../node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// ../../node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// ../../node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}

// ../../node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// ../../node_modules/date-fns/esm/addMinutes/index.js
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}

// ../../node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// ../../node_modules/date-fns/esm/subMinutes/index.js
function subMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}

// src/utils.ts
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var mkdir = import_util.promisify(import_fs.default.mkdir);
var read = import_util.promisify(import_fs.default.readFile);
var write = import_util.promisify(import_fs.default.writeFile);
var fileStats = import_util.promisify(import_fs.default.stat);
var rmdir = import_util.promisify(import_fs.default.rmdir);
var readDir = import_util.promisify(import_fs.default.readdir);
var copyFile = import_util.promisify(import_fs.default.copyFile);
var readJSON = (filePath) => read(filePath, "utf-8").then((contents) => JSON.parse(contents));
function failIfNot(condition, message) {
  if (!condition)
    throw new Error(message);
}
function failIf(condition, message) {
  if (condition)
    throw new Error(message);
}
var to = (p) => {
  return p.then((v) => [null, v]).catch((e) => [e, null]);
};
var resToReadable = (res) => {
  failIfNot(res.body, "Response has no body");
  if ("pipe" in res.body) {
    return res.body;
  }
  const reader = res.body.getReader();
  const readable = new import_stream.Readable();
  readable._read = async () => {
    const {done, value} = await reader.read();
    if (value)
      readable.push(done ? null : Buffer.from(value));
  };
  return readable;
};
var toRead = (...pathParts) => to(read(import_path.default.join(...pathParts), "utf-8"));
var toWrite = (payload, ...pathParts) => to(write(import_path.default.join(...pathParts), payload));
var toReadJSON = (...pathParts) => to(read(import_path.default.join(...pathParts), "utf-8").then((content) => JSON.parse(content)));
var fetchJSON = (...args) => fetchPolyfill(...args).then((res) => res.json());
var fetchToDisk = (input, outPath, init) => fetchPolyfill(input, init).then(async (res) => {
  const outputFileStream = import_fs.default.createWriteStream(outPath);
  const downloadStream = resToReadable(res);
  downloadStream.pipe(outputFileStream);
  return new Promise((resolve, reject) => {
    outputFileStream.on("error", reject);
    downloadStream.on("error", reject);
    downloadStream.on("end", resolve);
  });
});

// src/log.ts
var logger = (level, ...args) => {
};
var registerLogger = (fn) => {
  logger = (level, ...args) => {
    fn("obsidian-utils", level, ...args);
  };
};
var debug = (...args) => logger("debug", ...args);

// src/plugin/registry.ts
var DEFAULT_REGISTRY_URL = "https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugins.json";
var PluginRegistry2 = class {
  constructor(registryURL = DEFAULT_REGISTRY_URL) {
    this.registryURL = registryURL;
  }
  async updateRegistry() {
    debug("Fetching the plugin registry...");
    const [pluginRegistryFetchError, pluginRegistry] = await to(fetchPolyfill(this.registryURL).then((response) => response.json()));
    failIf(pluginRegistryFetchError, "Failed to fetch the plugin registry from github");
    PluginRegistry2._registry = pluginRegistry;
    debug("Plugin registry downloaded");
  }
  async getRegistry() {
    const registry = PluginRegistry2._registry;
    if (isBefore(registry.lastUpdated, subMinutes(Date.now(), 5))) {
      await this.updateRegistry();
    }
    return registry;
  }
  async getPlugin(pluginID) {
    const registry = await this.getRegistry();
    return registry.plugins.find((plugin) => plugin.id === pluginID);
  }
};
var PluginRegistry = PluginRegistry2;
PluginRegistry._registry = {
  lastUpdated: new Date(0),
  plugins: []
};

// src/plugin/install.ts
var import_fs2 = __toModule(require("fs"));
var import_path3 = __toModule(require("path"));

// src/plugin/utils.ts
var import_path2 = __toModule(require("path"));
var vaultPathToPluginsPath = (vaultPath) => {
  return import_path2.default.join(vaultPath, ".obsidian", "plugins");
};

// src/plugin/install.ts
async function installPluginFromGithub(repo, version, vaultPath) {
  var _a;
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const [pluginReleaseFetchError, pluginReleaseInfo] = await to(fetchPolyfill(version === "latest" ? `https://api.github.com/repos/${repo}/releases/latest` : `https://api.github.com/repos/${repo}/releases/tags/${version}`, {
    method: "GET",
    headers: {Accept: "application/vnd.github.v3+json"}
  }).then((response) => response.json()));
  failIf(pluginReleaseFetchError, `Failed to get release information from GitHub. You should install this plugin manually.`);
  debug(`retrieved release info from ${repo}`);
  debug("Finding manifest from release...");
  const manifestDownloadPath = (_a = pluginReleaseInfo.assets.find((asset) => asset.name === "manifest.json")) == null ? void 0 : _a.browser_download_url;
  failIfNot(manifestDownloadPath, `Didn't find a manifest.json file in release. Check it here: https://github.com/${repo}/releases/tag/${version}`);
  const [manifestDownloadError, manifest] = await to(fetchJSON(manifestDownloadPath));
  failIf(manifestDownloadError, `Failed to download manifest.json.
${manifestDownloadError}`);
  failIfNot(manifest, `manifest.json is empty`);
  const pluginID = manifest.id;
  const pluginPath = import_path3.default.join(pluginsPath, pluginID);
  debug("Creating plugin directory if it doesn't exist...");
  if (!import_fs2.default.existsSync(pluginPath)) {
    await mkdir(pluginPath, {recursive: true});
    debug("plugin directory successfully created");
  }
  await write(import_path3.default.join(pluginPath, "manifest.json"), JSON.stringify(manifest));
  await Promise.all(pluginReleaseInfo.assets.filter((asset) => asset.name !== "manifest.json" && (asset.name.endsWith(".js") || asset.name.endsWith(".json"))).map((asset) => fetchToDisk(asset.browser_download_url, import_path3.default.join(pluginPath, asset.name))));
  debug(`${pluginID} successfully installed`);
}
async function installPluginFromRegistry(pluginID, version, vaultPath, registry = new PluginRegistry()) {
  debug(`Attempting to install ${pluginID}`);
  debug("Trying to retrieve", pluginID, "from plugin registry");
  const plugin = await registry.getPlugin(pluginID);
  failIfNot(plugin, `Unable to install ${plugin}, it wasn't found in the registry.`);
  debug(pluginID, "found in plugin registry");
  return installPluginFromGithub(plugin.repo, version, vaultPath);
}
async function installLocalPlugin(pluginPath, vaultPath) {
  debug(`Attempting to install ${import_path3.default.basename(pluginPath)} to ${import_path3.default.basename(vaultPath)} vault`);
  const [manifestReadError, manifest] = await toReadJSON(pluginPath, "manifest.json");
  failIf(manifestReadError, `Failed to read manifest:
${manifestReadError}`);
  failIfNot(manifest, `Something went wrong, tried to read manifest but it was empty`);
  const {id} = manifest;
  const newPluginPath = import_path3.default.join(vaultPathToPluginsPath(vaultPath), id);
  if (import_fs2.default.existsSync(newPluginPath)) {
    debug("Plugin found with same name at the install location, removing it");
    await rmdir(newPluginPath, {recursive: true, force: true});
    await mkdir(newPluginPath);
  }
  const [readDirError, files] = await to(readDir(pluginPath));
  failIf(readDirError, `Something went wrong reading files from ${pluginPath}
${readDirError}`);
  failIfNot(files, `Something went wrong reading files from ${pluginPath}, expected to get files but got null instead`);
  for (const file of files) {
    await copyFile(import_path3.default.join(pluginPath, file), import_path3.default.join(newPluginPath, file));
  }
  debug("Install complete");
}

// src/plugin/local.ts
var import_path4 = __toModule(require("path"));
async function getInfoOnInstalledPlugin(pluginID, vaultPath) {
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const manifestPath = import_path4.default.join(pluginsPath, pluginID, "manifest.json");
  const [manifestReadError, manifest] = await toReadJSON(manifestPath);
  failIf(manifestReadError, `Manifest failed to load: ${manifestReadError}`);
  failIfNot(manifest, `Manifest loaded but wasn't defined`);
  const [, data] = await toReadJSON(vaultPath, pluginID, "data.json");
  const results = {
    manifest,
    data: data != null ? data : void 0,
    lastUpdated: (await fileStats(manifestPath)).mtime
  };
  debug(`Successfully fetched plugin from disk`);
  debug(results);
  return results;
}
async function isPluginInstalled(pluginID, vaultPath) {
  const pluginsPath = vaultPathToPluginsPath(vaultPath);
  const [manifestReadError, manifest] = await toReadJSON(pluginsPath, pluginID, "manifest.json");
  if (manifestReadError) {
    debug(`Got manifest error`, manifestReadError);
  }
  return manifestReadError || !manifest ? false : true;
}

// src/vault.ts
var import_os = __toModule(require("os"));
var import_path5 = __toModule(require("path"));
var import_fs3 = __toModule(require("fs"));
var isVault = (vaultPath) => {
  if (typeof vaultPath === "string" && import_fs3.default.existsSync(import_path5.default.join(vaultPath, ".obsidian"))) {
    return true;
  }
  return false;
};
var getVaultFromPath = (vaultPath, open) => {
  return {
    name: import_path5.default.basename(vaultPath),
    path: vaultPath,
    open
  };
};
var findVault = async (vaultPath) => {
  var _a;
  if (isVault(vaultPath)) {
    return [getVaultFromPath(vaultPath)];
  }
  if (vaultPath && import_fs3.default.existsSync(vaultPath)) {
    return [getVaultFromPath(vaultPath)];
  }
  const home = import_os.default.homedir();
  let obsidianPath = "";
  switch (import_os.default.platform()) {
    case "win32":
      obsidianPath = import_path5.default.join(home, "AppData", "Local", "Obsidian");
      break;
    case "darwin":
      obsidianPath = import_path5.default.join(home, "Library", "Application Support", "Obsidian");
      break;
    default: {
      const obsidianHomePath = import_path5.default.join(home, ".obsidian");
      const obsidianConfigPath = import_path5.default.join(home, ".config", "obsidian");
      const XDG = (_a = process.env.XDG) != null ? _a : "";
      const XDGPath = import_path5.default.join(XDG, "obsidian");
      obsidianPath = import_fs3.default.existsSync(obsidianConfigPath) ? obsidianConfigPath : XDG && import_fs3.default.existsSync(XDGPath) ? XDGPath : obsidianHomePath;
    }
  }
  failIf(!import_fs3.default.existsSync(obsidianPath), "Can't find obsidian settings directory, won't be able to read vaults");
  const [obsidianReadError, obsidian] = await to(readJSON(import_path5.default.join(obsidianPath, "obsidian.json")));
  failIf(obsidianReadError, `Could not read obsidian.json: ${obsidianReadError}
Vaults won't be retrievable`);
  return Object.values(obsidian.vaults).map((vault) => getVaultFromPath(vault.path, vault.open));
};
