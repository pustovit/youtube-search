/// <reference types="node" />
declare module "log" {
    /**
     * An injectable logger than can be provided by a consuming library
     *
     * `obsidian-utils` itself uses logger itself to provide extra context as to what's going on.
     * Given that it could be consumed in different environments (inside of obsidian, in a cli, etc) when
     * and how to display the logs seems outside the scope of this module. Instead, it provides a `registerLogger`
     * function that provides the ability to set the top level logger and control how it behaves.
     *
     * @packageDocumentation
     */
    type LogLevel = "debug" | "info" | "warn" | "error";
    /** Allows a consuming library to provide its own logger */
    export const registerLogger: (fn: (namespace: string, level: LogLevel, ...args: any[]) => void) => void;
    export const debug: (...args: any[]) => void;
    export const info: (...args: any[]) => void;
    export const warn: (...args: any[]) => void;
    export const error: (...args: any[]) => void;
}
declare module "utils" {
    import fs from "fs";
    export const mkdir: typeof fs.mkdir.__promisify__;
    export const read: typeof fs.readFile.__promisify__;
    export const write: typeof fs.writeFile.__promisify__;
    export const fileStats: typeof fs.stat.__promisify__;
    export const rmdir: typeof fs.rmdir.__promisify__;
    export const readDir: typeof fs.readdir.__promisify__;
    export const copyFile: typeof fs.copyFile.__promisify__;
    export const readJSON: (filePath: string) => Promise<any>;
    /** throws an exception if any falsy value is passed */
    export function failIfNot<T = any>(condition: T | null | undefined | false | 0, message: string): asserts condition is T;
    /** Throws an exception if any truthy vault is passed */
    export function failIf(condition: any, message: string): asserts condition is false | null | undefined | 0;
    /**
     * Inspired by `await-to-js`, this is a simple promise result handler that makes error handling
     * async code much less verbose. No `try`/`catch` statements needed!
     **/
    export const to: <T>(p: Promise<T>) => Promise<[null, T]> | Promise<[any, null]>;
    /** Async read pre-wrapped with {@link to} */
    export const toRead: (...pathParts: string[]) => Promise<[any, null]> | Promise<[null, string]>;
    export const toWrite: (payload: string, ...pathParts: string[]) => Promise<[any, null]> | Promise<[null, void]>;
    export const toReadJSON: <T>(...pathParts: string[]) => Promise<[any, null]> | Promise<[null, T]>;
    /** Helper to fetch and then convert the result to json */
    export const fetchJSON: (input: RequestInfo, init?: RequestInit | undefined) => Promise<any>;
    /**
     * An isomorphic method of downloading a file to disk. Compatible in both
     * electron's render instance and on node.
     */
    export const fetchToDisk: (input: RequestInfo, outPath: string, init?: RequestInit | undefined) => Promise<unknown>;
}
declare module "types" {
    export type Repo = `${string}/${string}`;
    export type PluginVersion = `${number}.${number}.${number}`;
    export type GitHubPluginVersion = "latest" | PluginVersion;
}
declare module "plugin/registry" {
    import { Repo } from "types";
    export interface PluginRegistryRecord {
        id: string;
        name: string;
        author: string;
        description: string;
        repo: Repo;
    }
    export interface PluginRegistryData {
        lastUpdated: Date;
        plugins: PluginRegistryRecord[];
    }
    export class PluginRegistry {
        private registryURL;
        private static _registry;
        constructor(registryURL?: string);
        private updateRegistry;
        getRegistry(): Promise<PluginRegistryData>;
        getPlugin(pluginID: string): Promise<PluginRegistryRecord | undefined>;
    }
}
declare module "plugin/utils" {
    export const vaultPathToPluginsPath: (vaultPath: string) => string;
}
declare module "plugin/install" {
    /**
     * This module is dedicated to the installation of plugins
     *
     * @packageDocumentation
     */
    import { PluginRegistry } from "plugin/registry";
    import { GitHubPluginVersion, Repo } from "types";
    /**
     * Given a repo short code, version, and the vault to install a plugin with, this
     * function downloads the plugin from GitHub's releases and adds it to the specified
     * vault.
     *
     * @param repo A short code reference a github repo formatted like `owner/repoName`
     * @param version Latest or a semver like 1.0.0
     * @param vaultPath Path to the vault in which the plugin should be installed
     */
    export function installPluginFromGithub(repo: Repo, version: GitHubPluginVersion, vaultPath: string): Promise<void>;
    export function installPluginFromRegistry(pluginID: string, version: GitHubPluginVersion, vaultPath: string, registry?: PluginRegistry): Promise<void>;
    /** Installs a plugin from the file system to a specified vault */
    export function installLocalPlugin(pluginPath: string, vaultPath: string): Promise<void>;
}
declare module "plugin/local" {
    import type { PluginManifest } from "obsidian";
    export interface InstalledPluginInfo {
        manifest: PluginManifest;
        data?: object;
        lastUpdated: Date;
    }
    /**
     * Gets information about an installed plugin including the contents of
     * its manifest.json, data.json (if it exists), and when the last time the
     * plugin was updated on disk.
     * @param vaultPath Path to the plugins directory in your vault. Usually something like `/path/to/vault/.obsidian/plugins`.
     * @param pluginID The ID of the plugin to read
     */
    export function getInfoOnInstalledPlugin(pluginID: string, vaultPath: string): Promise<InstalledPluginInfo>;
    export function isPluginInstalled(pluginID: string, vaultPath: string): Promise<boolean>;
}
declare module "plugin/index" {
    /**
     * A collection of utilities to install, read, and download plugins
     *
     * @packageDocumentation
     */
    export * from "plugin/install";
    export * from "plugin/local";
    export * from "plugin/registry";
    export * from "plugin/utils";
}
declare module "vault" {
    /**
     * A simpler vault representation that can be passed around for other tools
     * to do things with vaults
     */
    interface Vault {
        name: string;
        path: string;
        open?: boolean;
    }
    /** Determines if the given path is a path to a vault */
    export const isVault: (vaultPath: any) => boolean;
    /**
     * Attempts to find where your obsidian vaults are by locating obsidian's app config. It's relatively reliable
     * on Windows and OSX, but there may be issues on linux and will definitely be issues on weird platforms.
     * PRs welcome.
     *
     * @param vaultPath A path to an Obsidian vault (which, at the very least contains a .obsidian directory)
     */
    export const findVault: (vaultPath?: string | undefined) => Promise<Vault[]>;
}
declare module "obsidian-utils" {
    /**
     * A collections of tools to make programmatically interacting with obsidian simpler.
     *
     * ## Usage
     *
     * @example
     *
     * Use the utils to find your open vault and install a plugin from GitHub into it.
     *
     * ```
     * import { findVault, installPluginFromGithub } from 'obsidian-utils'
     * const myVault = await findVault();
     * await installPluginFromGithub('pjeby/hot-reload', 'latest', myVault.path)
     * ```
     *
     * @packageDocumentation
     */
    export * from "plugin/index";
    export * from "vault";
    export * from "utils";
    export { registerLogger } from "log";
}
